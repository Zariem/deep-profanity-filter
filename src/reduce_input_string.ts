import { BadWordMatchData } from './word_filter';

/**
 * The locations and lengths of segments in the string that were
 * uninterrupted by special characters.
 * This helps find the actual location of characters in the un-reduced string.
 */
type ReducedInputLocationInfo = {
  index: number;
  offset: number;
};

/**
 * Reduce a string by removing any special characters that are not latin characters,
 * numbers or whitespace. Keep track of the segment start indices and lengths so that
 * we can reverse engineer where each segment really started in the original string.
 * @param inputString - The string that needs to be reduced by removing all special characters.
 * @returns The reduced string (with all special characters removed), as well as an array
 * of start indices and lengths that indicate where each part of the string really started
 * and ended in the original string.
 */
export const reduceInputString = (
  inputString: string,
): { reducedInput: string; reducedLocations: ReducedInputLocationInfo[] } => {
  const matches = inputString.matchAll(/[a-zA-Z0-9\s]+/g);
  let outString = '';
  const locationInfo: ReducedInputLocationInfo[] = [];
  for (const match of matches) {
    locationInfo.push({
      index: outString.length,
      offset: match.index - outString.length,
    });
    outString += match[0];
  }

  return {
    reducedInput: outString,
    reducedLocations: locationInfo,
  };
};

/**
 * Reconstructs the original "Location Information" of a bad word in a string that got
 * reduced and then matched against a regular expression. Uses the information that was
 * gathered when reducing the string (by removing all special characters except whitespace).
 * @param reducedInfos - Information generated by `reduceInputString` before matching the
 * reduced string against a regular expression.
 * @param matchInfo - Information on the matched words and locations, gotten when matching
 * the string from `reduceInputString` against a regular expression.
 * @returns BadWordMatchData with the locations and lengths of the matches projected back
 * onto the original, unreduced string.
 */
export const reconstructLocations = (
  reducedInfos: ReducedInputLocationInfo[],
  matchInfo: BadWordMatchData[],
): BadWordMatchData[] => {
  const newMatchInfo: BadWordMatchData[] = [];
  for (const match of matchInfo) {
    const matchEndIndex = match.startIndex + match.length;
    let startOffset = 0;
    let endOffset = 0;
    for (const reducedInfo of reducedInfos) {
      if (reducedInfo.index <= match.startIndex) {
        startOffset = reducedInfo.offset;
        endOffset = reducedInfo.offset;
      } else if (reducedInfo.index < matchEndIndex) {
        endOffset = reducedInfo.offset;
      } else {
        break;
      }
    }
    newMatchInfo.push({
      word: match.word,
      startIndex: match.startIndex + startOffset,
      length: match.length + endOffset - startOffset,
    });
  }
  return newMatchInfo;
};
