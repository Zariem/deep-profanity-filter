import { BadWordData, WhitelistMap, ProcessedWordLists } from './wordlist_preprocessor';

/**
 * Information on a bad word that has been found, containing the index at which it starts
 * in the input string, as well as its length. Also contains a flag that indicated whether
 * a whitelisted word "nullifies" this bad word, so that we know to not test this word
 * for further whitelistings.
 */
type BadWordMatchInfo = {
  isWhitelisted: boolean;
  startIndex: number;
  length: number;
};

/**
 * Checks if the bad word is fully contained within the whitelisted word,
 * given their start indices and lengths.
 * @param badWordStartIndex - The index at which the bad word starts in the input string.
 * @param badWordLength - The length of the bad word in the input string.
 * @param goodWordStartIndex - The index at which the whitelisted word starts in the input string.
 * @param goodWordLength - The length of the whitelisted word in the input string.
 * @returns True, if the bad word is fully contained in this whitelisted term. False, otherwise.
 */
const isMatchWhitelisted = (badWordStartIndex, badWordLength, goodWordStartIndex, goodWordLength): boolean => {
  return (
    badWordStartIndex >= goodWordStartIndex && badWordStartIndex + badWordLength <= goodWordStartIndex + goodWordLength
  );
};

/**
 * Checks for a bad word in a given input string. Includes checks of the whitelist,
 * in order to ensure that whitelisted occurrences of bad words are not considered "bad".
 * Can check either strictly, considering circumvention attempts, or non-strictly,
 * considering only whether the bad word (or phrase) itself appears in the input string.
 * @param inputString - The text to check for bad words.
 * @param badwordData - The data for one bad word - from of the array of bad word data generated by `preprocessWordLists`
 * @param whitelistMap - The map of whitelisted words, generated by `preprocessWordLists`
 * @param checkStrict - Whether to check for circumventions or not.
 * @returns True if the bad word was found (and not whitelisted),
 *          false if no bad word was found, or all bad words were whitelisted.
 */
export const hasBadWord = (
  inputString: string,
  badwordData: BadWordData,
  whitelistMap: WhitelistMap,
  checkStrict: boolean,
): boolean => {
  const badwordRegExp = checkStrict ? badwordData.strictRegexp : badwordData.normalRegexp;
  const matches = inputString.matchAll(badwordRegExp);

  // make a checklist of which matches we found, remove them once we see they are whitelisted
  let badWordMatchData: BadWordMatchInfo[] = [];
  for (const match of matches) {
    badWordMatchData.push({
      isWhitelisted: false,
      startIndex: match.index,
      length: match[0].length,
    });
  }
  if (badWordMatchData.length === 0) {
    return false; // no bad word was found
  }
  if (!whitelistMap[badwordData.word] || whitelistMap[badwordData.word].length === 0) {
    // some bad words were found and we have no whitelisted terms for them
    return true;
  }

  // if we are checking for bad word circumventions also check the specific "strict" whitelist
  // that avoids blocking good content such as "s h e l l" for discovering bad content within, such as "h e l l"
  const whitelistRegexData = checkStrict
    ? whitelistMap[badwordData.word].map((elem) => elem.strictRegexp).concat(badwordData.whitelistedStrictRegexpArray)
    : whitelistMap[badwordData.word].map((elem) => elem.normalRegexp);

  // iterate through the whitelist that overlaps with this bad word,
  // based on start index and match length, we can determine if a bad word
  // is okay to be used (i.e. whether it is whitelisted).
  for (const whitelistRegex of whitelistRegexData) {
    const whitelistMatches = inputString.matchAll(whitelistRegex);
    if (whitelistMatches) {
      for (const whitelistMatch of whitelistMatches) {
        for (const badWordElement of badWordMatchData) {
          if (
            isMatchWhitelisted(
              badWordElement.startIndex,
              badWordElement.length,
              whitelistMatch.index,
              whitelistMatch[0].length,
            )
          ) {
            badWordElement.isWhitelisted = true; // remove later, to not break the loop
          }
        }
        badWordMatchData = badWordMatchData.filter((element) => !element.isWhitelisted);
        if (badWordMatchData.length === 0) {
          return false; //  early out - all bad words were whitelisted
        }
      }
    }
  }

  // If we still have some bad words in the list, it means not all of them were whitelisted.
  return badWordMatchData.length > 0;
};

/**
 * Given your preprocessed bad word list and whitelist, checks if a given text contains any bad word
 * that hasn't been allowed by the whitelist. Checks for the most common circumventions as well.
 *
 * IMPORTANT: Make sure that any backslash in the inputString is escaped correctly.
 * If you are trying to see whether the string `¯\_(ツ)_/¯` is a bad word, you have to
 * enter it as `¯\\_(ツ)_/¯` to match it correctly.
 *
 * @param inputString - The text you wish to check for bad words.
 * @param processedWordLists - The preprocessed bad word list and whitelist, generated by `preprocessWordLists(...)`
 * @returns True if any bad word was found, false if no bad word was found or all bad words were whitelisted.
 */
export const doesContainBadWords = (inputString: string, processedWordLists: ProcessedWordLists) => {
  for (const badwordData of processedWordLists.badWordData) {
    // first try to match the word with its special characters, as they could
    // form word boundaries, such as in "test-kitty-word".
    if (hasBadWord(inputString, badwordData, processedWordLists.whitelistMap, false)) {
      return true;
    }

    // then try removing all special characters from the input string
    // and match it against the word itself, with word boundaries.
    const reducedInput = inputString.replace(/[^a-zA-Z0-9\s]/g, '');
    if (reducedInput !== inputString && hasBadWord(reducedInput, badwordData, processedWordLists.whitelistMap, false)) {
      return true;
    }

    // finally try to match the word with common circumventions, such as
    // "bad k i t t y" while ensuring words such as "k i t t y c a t" are considered bad.
    if (hasBadWord(inputString, badwordData, processedWordLists.whitelistMap, true)) {
      return true;
    }
  }

  return false;
};
